create table "public"."check_in_flavors" (
    "check_in_id" bigint,
    "flavor_id" bigint
);


create table "public"."check_in_tagged_profiles" (
    "check_in_id" bigint not null,
    "profile_id" uuid not null,
    "created_at" timestamp with time zone default now()
);


create table "public"."flavors" (
    "id" bigint generated by default as identity not null,
    "name" text
);


create table "public"."locations" (
    "id" bigint generated by default as identity not null,
    "country" text not null,
    "city" text not null,
    "name" text
);


create table "public"."serving_styles" (
    "id" bigint generated by default as identity not null,
    "category_id" bigint not null,
    "name" text not null
);


alter table "public"."check_ins" add column "location_id" bigint;

alter table "public"."check_ins" add column "manufacturer_id" bigint;

alter table "public"."check_ins" add column "purchase_location_id" bigint;

alter table "public"."check_ins" add column "serving_style_id" bigint;

alter table "public"."companies" add column "logo_url" text;

CREATE UNIQUE INDEX check_in_flavors_check_in_id_flavor_id_key ON public.check_in_flavors USING btree (check_in_id, flavor_id);

CREATE UNIQUE INDEX check_in_tagged_profiles_check_in_id_profile_id_key ON public.check_in_tagged_profiles USING btree (check_in_id, profile_id);

CREATE UNIQUE INDEX flavors_name_key ON public.flavors USING btree (name);

CREATE UNIQUE INDEX flavors_pkey ON public.flavors USING btree (id);

CREATE UNIQUE INDEX locations_country_city_name_key ON public.locations USING btree (country, city, name);

CREATE UNIQUE INDEX locations_pkey ON public.locations USING btree (id);

CREATE UNIQUE INDEX serving_styles_pkey ON public.serving_styles USING btree (id);

CREATE UNIQUE INDEX unique_name_category ON public.serving_styles USING btree (name, category_id);

alter table "public"."flavors" add constraint "flavors_pkey" PRIMARY KEY using index "flavors_pkey";

alter table "public"."locations" add constraint "locations_pkey" PRIMARY KEY using index "locations_pkey";

alter table "public"."serving_styles" add constraint "serving_styles_pkey" PRIMARY KEY using index "serving_styles_pkey";

alter table "public"."check_in_flavors" add constraint "check_in_flavors_check_in_id_fkey" FOREIGN KEY (check_in_id) REFERENCES check_ins(id) ON DELETE CASCADE not valid;

alter table "public"."check_in_flavors" validate constraint "check_in_flavors_check_in_id_fkey";

alter table "public"."check_in_flavors" add constraint "check_in_flavors_check_in_id_flavor_id_key" UNIQUE using index "check_in_flavors_check_in_id_flavor_id_key";

alter table "public"."check_in_flavors" add constraint "check_in_flavors_flavor_id_fkey" FOREIGN KEY (flavor_id) REFERENCES flavors(id) ON DELETE CASCADE not valid;

alter table "public"."check_in_flavors" validate constraint "check_in_flavors_flavor_id_fkey";

alter table "public"."check_in_tagged_profiles" add constraint "check_in_tagged_profiles_check_in_id_fkey" FOREIGN KEY (check_in_id) REFERENCES check_ins(id) ON DELETE CASCADE not valid;

alter table "public"."check_in_tagged_profiles" validate constraint "check_in_tagged_profiles_check_in_id_fkey";

alter table "public"."check_in_tagged_profiles" add constraint "check_in_tagged_profiles_check_in_id_profile_id_key" UNIQUE using index "check_in_tagged_profiles_check_in_id_profile_id_key";

alter table "public"."check_in_tagged_profiles" add constraint "check_in_tagged_profiles_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."check_in_tagged_profiles" validate constraint "check_in_tagged_profiles_profile_id_fkey";

alter table "public"."check_ins" add constraint "check_ins_location_id_fkey" FOREIGN KEY (location_id) REFERENCES locations(id) ON DELETE SET NULL not valid;

alter table "public"."check_ins" validate constraint "check_ins_location_id_fkey";

alter table "public"."check_ins" add constraint "check_ins_manufacturer_id_fkey" FOREIGN KEY (manufacturer_id) REFERENCES companies(id) ON DELETE SET NULL not valid;

alter table "public"."check_ins" validate constraint "check_ins_manufacturer_id_fkey";

alter table "public"."check_ins" add constraint "check_ins_purchase_location_id_fkey" FOREIGN KEY (purchase_location_id) REFERENCES locations(id) ON DELETE CASCADE not valid;

alter table "public"."check_ins" validate constraint "check_ins_purchase_location_id_fkey";

alter table "public"."check_ins" add constraint "check_ins_serving_style_id_fkey" FOREIGN KEY (serving_style_id) REFERENCES serving_styles(id) ON DELETE SET NULL not valid;

alter table "public"."check_ins" validate constraint "check_ins_serving_style_id_fkey";

alter table "public"."flavors" add constraint "flavors_name_key" UNIQUE using index "flavors_name_key";

alter table "public"."locations" add constraint "locations_country_city_name_key" UNIQUE using index "locations_country_city_name_key";

alter table "public"."serving_styles" add constraint "serving_style_category_id_fkey" FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE CASCADE not valid;

alter table "public"."serving_styles" validate constraint "serving_style_category_id_fkey";

alter table "public"."serving_styles" add constraint "unique_name_category" UNIQUE using index "unique_name_category";

set check_function_bodies = off;

CREATE OR REPLACE PROCEDURE public.seed_data()
 LANGUAGE plpgsql
AS $procedure$
BEGIN
    insert into categories (name) values ('Beverage') on conflict do nothing;

    with existing_beverage_id as (select id from categories where name = 'Beverage'),
         serving_styles_for_beverage as (select unnest(array['can', 'bottle', 'carton']) name)
    insert
    into serving_styles (name, category_id)
    select ssb.name, ex.id category_id
    from existing_beverage_id ex
             cross join serving_styles_for_beverage ssb;
END
$procedure$
;

create or replace view "public"."csv_export" as  WITH agg_products AS (
         SELECT cat.name AS category,
            string_agg(sc.name, ', '::text ORDER BY sc.name) AS subcategory,
            bo.name AS brand_owner,
            b.name AS brand,
            s.name AS "sub-brand",
            p.name,
            p.id
           FROM ((((((products p
             LEFT JOIN "sub-brands" s ON ((p."sub-brand_id" = s.id)))
             LEFT JOIN brands b ON ((s.brand_id = b.id)))
             LEFT JOIN companies bo ON ((b.brand_owner_id = bo.id)))
             LEFT JOIN categories cat ON ((p.category_id = cat.id)))
             LEFT JOIN products_subcategories ps ON ((ps.product_id = p.id)))
             LEFT JOIN subcategories sc ON ((ps.subcategory_id = sc.id)))
          GROUP BY cat.name, bo.name, b.name, p.name, s.name, p.description, p.id
        )
 SELECT ap.category,
    ap.subcategory,
    m.name AS manufacturer,
    ap.brand_owner,
    ap.brand,
    ap."sub-brand",
    ap.name,
    ap.id,
    string_agg(c.review, ', '::text) AS reviews,
    string_agg((((c.rating)::double precision / (2)::double precision))::text, ', '::text) AS ratings,
    pr.username
   FROM (((check_ins c
     LEFT JOIN agg_products ap ON ((ap.id = c.product_id)))
     LEFT JOIN companies m ON ((c.manufacturer_id = m.id)))
     LEFT JOIN profiles pr ON ((c.created_by = pr.id)))
  GROUP BY pr.username, ap.category, ap.subcategory, m.name, ap.brand_owner, ap.brand, ap."sub-brand", ap.name, ap.id;



