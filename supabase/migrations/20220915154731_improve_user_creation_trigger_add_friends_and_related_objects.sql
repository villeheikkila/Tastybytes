create type "public"."friend_status" as enum ('accepted', 'pending', 'blocked');

drop function if exists "public"."handle_new_user"();

create table "public"."friends" (
    "id" bigint generated by default as identity not null,
    "user_id_1" uuid not null,
    "user_id_2" uuid not null,
    "status" friend_status not null default 'pending'::friend_status,
    "accepted_at" date,
    "blocked_by" uuid,
    "created_at" date not null default now()
);


alter table "public"."profiles" alter column "username" set not null;

CREATE UNIQUE INDEX friends_pkey ON public.friends USING btree (id);

CREATE UNIQUE INDEX one_reaction_per_user ON public.check_in_reactions USING btree (check_in_id, created_by);

alter table "public"."friends" add constraint "friends_pkey" PRIMARY KEY using index "friends_pkey";

alter table "public"."check_in_reactions" add constraint "one_reaction_per_user" UNIQUE using index "one_reaction_per_user";

alter table "public"."friends" add constraint "friends_blocked_by_fkey" FOREIGN KEY (blocked_by) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."friends" validate constraint "friends_blocked_by_fkey";

alter table "public"."friends" add constraint "friends_check" CHECK ((user_id_1 <> user_id_2)) not valid;

alter table "public"."friends" validate constraint "friends_check";

alter table "public"."friends" add constraint "friends_user_id_1_fkey" FOREIGN KEY (user_id_1) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."friends" validate constraint "friends_user_id_1_fkey";

alter table "public"."friends" add constraint "friends_user_id_2_fkey" FOREIGN KEY (user_id_2) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."friends" validate constraint "friends_user_id_2_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.accept_friend_request(user_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
    update friends
    set status = 'accepted'
    where user_id_1 = user_id
      and user_id_2 = auth.uid();
end;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_check_friend_status_transition()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    if old.status = 'blocked' and
       new.status = 'accepted' then
        new.blocked_by = null;
    elseif old.status in ('accepted', 'blocked') and
           new.status = 'pending' then
        raise exception 'friend status cannot be changed back to pending';
    end if;
    return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_create_profile_for_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
    v_username text;
begin
    select split_part(email, '@', 1)
    from auth.users
    into v_username where id = new.id;

    insert
    into public.profiles (id, username)
    values (new.id, v_username);
    return new;
end;
$function$
;


