-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

CREATE OR REPLACE FUNCTION public.fnc__create_product(IN p_name text,IN p_description text,IN p_category_id bigint,IN p_sub_category_ids bigint[],IN p_brand_id bigint,IN p_sub_brand_id bigint DEFAULT NULL::bigint)
    RETURNS SETOF products
    LANGUAGE 'plpgsql'
    VOLATILE
    PARALLEL UNSAFE
    COST 100    ROWS 1000 
    
AS $BODY$
DECLARE
  v_product_id   bigint;
  v_sub_brand_id bigint;
  v_product_name text;
  v_product_description text;
BEGIN
  if trim(p_name) = '' then
    raise exception 'product name can`t be empty' using errcode = 'no_name';
  end if;

  if trim(p_description) = '' then
    v_product_description = null;
  else
    v_product_description = trim(p_description);
  end if;

  if p_sub_brand_id is null then
    insert into sub_brands (name, brand_id, created_by)
    values (null, p_brand_id, auth.uid())
    returning id into v_sub_brand_id;
  else
    v_sub_brand_id = p_sub_brand_id;
  end if;

  insert into products (name, description, category_id, sub_brand_id, created_by)
  values (v_product_name, v_product_description, p_category_id, v_sub_brand_id, auth.uid())
  returning id into v_product_id;

  with subcategories_for_product as (select unnest(p_sub_category_ids) subcategory_id, v_product_id product_id)
  insert
  into products_subcategories (product_id, subcategory_id, created_by)
  select product_id, subcategory_id, auth.uid() created_by
  from subcategories_for_product;

  return query (select *
                from products
                where id = v_product_id);
END

$BODY$;

CREATE OR REPLACE FUNCTION public.fnc__create_company_edit_suggestion(IN p_company_id bigint,IN p_name text,IN p_logo_url text)
    RETURNS SETOF company_edit_suggestions
    LANGUAGE 'plpgsql'
    VOLATILE
    PARALLEL UNSAFE
    COST 100    ROWS 1000 
    
AS $BODY$
DECLARE
  v_company_edit_suggestion_id bigint;
  v_changed_name               text;
  v_changed_logo_url           text;
  v_current_company            companies%ROWTYPE;
BEGIN
  select * from companies where id = p_company_id into v_current_company;

  if v_current_company.name != p_name then
    v_changed_name = p_name;
  end if;

  if v_current_company.name != p_logo_url then
    v_changed_logo_url = p_logo_url;
  end if;

  insert into company_edit_suggestions (company_id, name, logo_url, created_by)
  values (p_company_id, v_changed_name, v_changed_logo_url, auth.uid())
  returning id into v_company_edit_suggestion_id;

  return query (select *
                from company_edit_suggestions
                where id = v_company_edit_suggestion_id);
END

$BODY$;

CREATE OR REPLACE FUNCTION public.fnc__create_product_edit_suggestion(IN p_product_id bigint,IN p_name text,IN p_description text,IN p_category_id bigint,IN p_sub_category_ids bigint[],IN p_sub_brand_id bigint DEFAULT NULL::bigint)
    RETURNS SETOF product_edit_suggestions
    LANGUAGE 'plpgsql'
    VOLATILE
    PARALLEL UNSAFE
    COST 100    ROWS 1000 
    
AS $BODY$
DECLARE
  v_product_edit_suggestion_id bigint;
  v_changed_name               text;
  v_changed_description        text;
  v_changed_category_id        bigint;
  v_changed_sub_brand_id       bigint;
  v_current_product            products%ROWTYPE;
BEGIN
  select * from products where id = p_product_id into v_current_product;

  if v_current_product.name != p_name then
    v_changed_name = p_name;
  end if;

  if v_current_product.name != p_description then
    v_changed_description = p_description;
  end if;

  if v_current_product.description != p_description then
    v_changed_description = p_description;
  end if;

  if v_current_product.category_id != p_category_id then
    v_changed_category_id = p_category_id;
  end if;

  if v_current_product.sub_brand_id != p_sub_brand_id then
    v_changed_sub_brand_id = p_sub_brand_id;
  end if;

  insert into product_edit_suggestions (product_id, name, description, category_id, sub_brand_id, created_by)
  values (p_product_id, v_changed_name, v_changed_description, v_changed_category_id, v_changed_sub_brand_id,
          auth.uid())
  returning id into v_product_edit_suggestion_id;

  with subcategories_for_product as (select v_product_edit_suggestion_id product_edit_suggestion_id,
                                            unnest(p_sub_category_ids)   subcategory_id),
       current_subcategories as (select subcategory_id from products_subcategories where product_id = p_product_id),
       delete_subcategories as (select o.subcategory_id
                                from current_subcategories o
                                       left join subcategories_for_product n on n.subcategory_id = o.subcategory_id
                                where n is null),
       add_subcategories as (select n.subcategory_id
                             from subcategories_for_product n
                                    left join current_subcategories o on o.subcategory_id is null
                             where o.subcategory_id is null),
       combined as (select subcategory_id, true delete
                    from delete_subcategories
                    union all
                    select subcategory_id, false
                    from add_subcategories)
  insert
  into product_edit_suggestion_subcategories (product_edit_suggestion_id, subcategory_id, delete)
  select v_product_edit_suggestion_id product_edit_suggestion_id, subcategory_id, delete
  from combined;

  return query (select *
                from product_edit_suggestions
                where id = v_product_edit_suggestion_id);
END

$BODY$;

REVOKE ALL ON TABLE public.product_variants FROM authenticated;
REVOKE ALL ON TABLE public.product_variants FROM postgres;
REVOKE ALL ON TABLE public.product_variants FROM service_role;
GRANT ALL ON TABLE public.product_variants TO authenticated;

GRANT ALL ON TABLE public.product_variants TO service_role;

GRANT ALL ON TABLE public.product_variants TO postgres;

REVOKE ALL ON TABLE public.friends FROM anon;
REVOKE ALL ON TABLE public.friends FROM postgres;
REVOKE ALL ON TABLE public.friends FROM service_role;
GRANT ALL ON TABLE public.friends TO anon;

GRANT ALL ON TABLE public.friends TO service_role;

GRANT ALL ON TABLE public.friends TO postgres;

REVOKE ALL ON TABLE public.products FROM authenticated;
REVOKE ALL ON TABLE public.products FROM postgres;
REVOKE ALL ON TABLE public.products FROM service_role;
GRANT ALL ON TABLE public.products TO authenticated;

GRANT ALL ON TABLE public.products TO service_role;

GRANT ALL ON TABLE public.products TO postgres;

REVOKE ALL ON TABLE public.products_subcategories FROM authenticated;
REVOKE ALL ON TABLE public.products_subcategories FROM postgres;
REVOKE ALL ON TABLE public.products_subcategories FROM service_role;
GRANT ALL ON TABLE public.products_subcategories TO authenticated;

GRANT ALL ON TABLE public.products_subcategories TO service_role;

GRANT ALL ON TABLE public.products_subcategories TO postgres;

REVOKE ALL ON TABLE public.companies FROM anon;
REVOKE ALL ON TABLE public.companies FROM authenticated;
REVOKE ALL ON TABLE public.companies FROM service_role;
GRANT ALL ON TABLE public.companies TO authenticated;

GRANT ALL ON TABLE public.companies TO anon;

GRANT ALL ON TABLE public.companies TO service_role;

REVOKE ALL ON TABLE public.notifications FROM authenticated;
REVOKE ALL ON TABLE public.notifications FROM postgres;
REVOKE ALL ON TABLE public.notifications FROM service_role;
GRANT ALL ON TABLE public.notifications TO authenticated;

GRANT ALL ON TABLE public.notifications TO service_role;

GRANT ALL ON TABLE public.notifications TO postgres;

REVOKE ALL ON TABLE public.check_in_reactions FROM authenticated;
REVOKE ALL ON TABLE public.check_in_reactions FROM postgres;
REVOKE ALL ON TABLE public.check_in_reactions FROM service_role;
GRANT ALL ON TABLE public.check_in_reactions TO authenticated;

GRANT ALL ON TABLE public.check_in_reactions TO service_role;

GRANT ALL ON TABLE public.check_in_reactions TO postgres;

REVOKE ALL ON TABLE public.product_edit_suggestions FROM authenticated;
REVOKE ALL ON TABLE public.product_edit_suggestions FROM postgres;
REVOKE ALL ON TABLE public.product_edit_suggestions FROM service_role;
GRANT ALL ON TABLE public.product_edit_suggestions TO authenticated;

GRANT ALL ON TABLE public.product_edit_suggestions TO service_role;

GRANT ALL ON TABLE public.product_edit_suggestions TO postgres;

REVOKE ALL ON TABLE public.subcategories FROM authenticated;
REVOKE ALL ON TABLE public.subcategories FROM postgres;
REVOKE ALL ON TABLE public.subcategories FROM service_role;
GRANT ALL ON TABLE public.subcategories TO authenticated;

GRANT ALL ON TABLE public.subcategories TO service_role;

GRANT ALL ON TABLE public.subcategories TO postgres;

REVOKE ALL ON TABLE public.brands FROM authenticated;
REVOKE ALL ON TABLE public.brands FROM postgres;
REVOKE ALL ON TABLE public.brands FROM service_role;
GRANT ALL ON TABLE public.brands TO authenticated;

GRANT ALL ON TABLE public.brands TO service_role;

GRANT ALL ON TABLE public.brands TO postgres;

REVOKE ALL ON TABLE public.sub_brands FROM anon;
REVOKE ALL ON TABLE public.sub_brands FROM postgres;
REVOKE ALL ON TABLE public.sub_brands FROM service_role;
GRANT ALL ON TABLE public.sub_brands TO anon;

GRANT ALL ON TABLE public.sub_brands TO service_role;

GRANT ALL ON TABLE public.sub_brands TO postgres;

REVOKE ALL ON TABLE public.check_ins FROM anon;
REVOKE ALL ON TABLE public.check_ins FROM authenticated;
REVOKE ALL ON TABLE public.check_ins FROM postgres;
REVOKE ALL ON TABLE public.check_ins FROM service_role;
GRANT ALL ON TABLE public.check_ins TO authenticated;

GRANT ALL ON TABLE public.check_ins TO anon;

GRANT ALL ON TABLE public.check_ins TO service_role;

GRANT ALL ON TABLE public.check_ins TO postgres;
